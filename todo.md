api部分，json对外，protobuf对内


1.msg后续改为proto协议
    可以开始时直接使用结构体定义消息，等到系统逐渐扩展时，转换到 Protobuf 或其他协议。
    甚至可以在系统中同时使用两者，内部通信使用 Protobuf，外部接口（如 WebSocket、HTTP）则使用 JSON 格式。



从目前的代码架构来看，已经有了 WebSocket 连接管理、消息解析与存储、以及业务层（Handler）的基本实现，能够处理基本的 IM 和实时推送场景。
但是，要实现一个真正的 Socket.IO 替代品，并达到“高并发、可扩展、分布式、不受版本问题影响”的目标，还需要补充和完善以下几个关键方面：

1. 断线恢复与心跳检测
心跳机制：
定期发送 ping/pong 消息，确保客户端连接保持活跃，及时检测断线。
例如，在每个 Client 或 ConnectionManager 里增加心跳检测逻辑。

断线重连支持：
服务器应能处理客户端重连，并恢复之前的会话状态（如订阅的房间、未读消息等）。

2. 分布式支持
跨节点消息传递：
当系统部署成集群时，如何让不同节点之间共享连接信息和消息需要一个分布式方案。
常见的做法是使用 Redis Pub/Sub、Kafka 等消息中间件来做节点间的消息同步和广播。

共享状态存储：
使用 Redis 或其他 NoSQL 数据库来存储在线用户、房间信息、离线消息等，以实现高可用性和数据一致性。

3. 命名空间与房间管理
命名空间（Namespace）：
类似 Socket.IO 的概念，为不同类型的应用场景提供隔离。
的房间管理已经初步实现，但可以扩展为支持命名空间，以便让不同业务之间互不干扰。

更复杂的房间管理：
如房间权限、房间广播、加入/退出通知、房间状态同步等。

4. 事件驱动模型
事件注册与监听：
支持类似 Socket.IO 的事件机制，让客户端可以注册特定的事件回调，服务器端可以触发相应事件。
这需要设计一套事件路由机制，而不仅仅是简单的消息解析。

5. 消息持久化与离线消息
历史消息存储：
对于 IM 应用，消息持久化非常重要，客户端离线后重新上线时能同步历史记录。
可以集成数据库（如 MySQL、MongoDB）存储聊天记录。

离线消息队列：
将未能实时推送的消息存储起来，在用户上线后补发。

6. 安全与认证
强化身份认证与授权：
除了基本的 JWT 验证，还需要考虑多设备登录、权限管理等。
可以引入 HTTPS、WSS（加密的 WebSocket）等来保证通信安全。

7. API 接口
REST API：
除了实时通信，系统还可以提供 RESTful API 用于查询在线用户、历史消息、房间信息等。
这有助于和前端或其他服务的集成。

8. 监控与日志
性能监控：
集成实时监控系统（如 Prometheus、Grafana）来监控连接数、消息吞吐量、响应时间等关键指标。

结构化日志：
建议使用结构化日志输出，方便后续排查问题和进行系统调优。

9. 可扩展性与插件化
插件系统：
如果未来需要扩展功能，可以设计一个插件系统，允许用户添加自定义的事件处理器、消息过滤器等。

10. 测试与文档
全面的单元测试与压力测试：
确保在高并发和分布式环境下系统稳定运行。

详细的开发文档与 API 文档：
便于开源社区贡献和使用。

最终架构总结
ConnectionManager
只负责 WebSocket 连接的管理，包括添加、删除、心跳检测和断线处理。

MessageManager
只负责消息的解析、存储和持久化（如果需要），不直接负责消息转发。
（消息转发由 Handler 通过调用 ConnectionManager 的接口完成）

Handler
负责业务逻辑，包括接收消息、判断消息类型，并调用 ConnectionManager 发起单发、群发、广播等操作。

RoomManager（或 Namespace/Room）
负责房间和命名空间的管理，支持群聊和频道功能。

AuthManager
负责用户身份认证和授权管理。

HTTP Server
作为入口处理 HTTP/WebSocket 握手和 REST API 请求。

分布式支持模块（如 Redis/Kafka 集成）
实现跨节点消息同步和共享状态存储。

当前代码已经实现了基础功能，但为了达到最终目标，需要补充以上提到的各个模块和功能。

这种架构能让逐步构建一个高并发、可扩展、分布式的 Socket.IO 替代品，适用于 IM、推送、实时协作等多种场景。



| 方面         | MQTT                                  | WebSocket                                |
| ---------- | ------------------------------------- | ---------------------------------------- |
| **协议类型**   | 应用层协议，基于发布/订阅模式                       | 传输层协议（双向 TCP 连接），双工通信                    |
| **设计目的**   | 轻量级消息传输，适合物联网和移动设备                    | 浏览器和服务器之间全双工通信                           |
| **通信模式**   | 发布/订阅，客户端订阅主题，Broker 转发消息             | 点对点，客户端和服务器直接通信                          |
| **消息格式**   | 轻量二进制协议，有固定包头，支持 QoS 0/1/2            | 自定义文本或二进制消息，协议层不限制消息格式                   |
| **连接方式**   | 长连接，支持会话持久化和断线重连                      | 长连接，通常需要自己实现断线重连和心跳                      |
| **QoS 支持** | 有三种服务质量保证机制（0-最多一次，1-至少一次，2-只有一次）     | 无内建 QoS，消息发送不保证送达                        |
| **订阅机制**   | 支持主题和通配符订阅，灵活广播消息                     | 不支持订阅机制，需自己实现频道或广播逻辑                     |
| **安全性**    | 支持 TLS/SSL 加密，且有用户认证和 ACL             | 也支持 TLS/SSL（wss），认证机制需自己实现               |
| **适用场景**   | 物联网、移动消息推送、轻量级消息传递                    | 实时网页通信、聊天系统、游戏、任何需要双向实时通信的场景             |
| **复杂度**    | 协议复杂度较高，需要 Broker 支持                  | 协议简单，依赖于应用层自定义消息格式和业务逻辑                  |
| **服务端架构**  | 需要专门的 Broker（如 Mosquitto、EMQX、HiveMQ） | 只要支持 WebSocket 的服务器即可（如 Node.js、Go、Java） |

| 技术/方案             | 描述                | 适用场景            | 优缺点                 |
| ----------------- | ----------------- | --------------- | ------------------- |
| **Netty + 自研协议**  | 灵活高性能，完全自主设计协议和功能 | 大型复杂IM，企业级产品    | 开发复杂，成本高，灵活度最大      |
| **MQTT**          | 轻量级发布/订阅消息协议      | 物联网消息推送，轻量IM    | 弱网支持好，协议简单，功能有限     |
| **WebSocket**     | 浏览器和客户端双向通信标准     | 跨平台即时通信，网页端及App | 易用，兼容好，需自行实现可靠性机制   |
| **XMPP**          | 开源的即时通讯协议标准       | 企业聊天，跨平台        | 标准成熟，扩展多，协议较重，复杂度较高 |
| **HTTP/2 + Push** | 基于HTTP/2的长连接推送    | 移动端消息推送，推送通知    | 适合简单消息，延迟较高         |
| **gRPC**          | 基于HTTP/2的高性能RPC框架 | 内部服务通信，低延迟RPC   | 适合服务间通信，不是专门的IM协议   |



20250407
    关于handler和server重复内容的问题，我在系统3里面做过尝试，目前先用这种简单的方法继续。后续做wire依赖注入。我要确认好，这俩东西的作用分别是什么。handler叫logic是否更合适？
    配置管理
    我需要把每个internal结构，做成一个接口，接口有一些方法
    网关，我是用nginx好还是自己写个api网关好？


20250620
    servergo是把一堆东西放到service里，而跟计算逻辑相关的操作，都封装到了logic的方法里，所以它其实就2个东西，一个service，一个logic
    其余新的东西都放到pkg里面了

20250624
💬 你不需要给每个用户之间双向Ping，只需客户端→服务端Ping，服务端管理用户心跳，更新用户在线状态，然后通过推送或者客户端拉取更新头像绿标。

20250626 websocket=>mqtt，no=》 netty  // 这个最后做，

20250701 用户密钥认证，用户登陆和互相发消息。

20250709 拆成微服务架构,traceID加入到ctx里面，全程跟踪